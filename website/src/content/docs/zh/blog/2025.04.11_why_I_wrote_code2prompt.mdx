---
title: "为什么我开发了Code2Prompt"
date: 2025-04-11
lastUpdated: 2025-04-11
tags:
  - 开源
  - code2prompt
  - AI
  - 智能代理
excerpt: "code2prompt背后的故事：我为了解决LLM工作流中的上下文挑战而进行的开源探索"
authors:
  - ODAncona
cover:
  alt: "code2prompt简化AI智能体代码上下文的示意图"
  image: "/src/assets/logo_dark_v0.0.2.svg"
featured: false
draft: false
---

## 介绍

我一直对大型语言模型（LLMs）如何改变编码工作流程感到着迷——它们可以生成测试、文档字符串，甚至在几分钟内完成整个功能的编写。但当我进一步推动这些模型时，几个关键的痛点不断出现：

| 规划困难 | 高Token成本 | 幻觉     |
| -------- | ----------- | -------- |
| 🧠 ➡️ 🤯 | 🔥 ➡️ 💸    | 💬 ➡️ 🌀 |

这就是为什么我开始为`code2prompt`做出贡献，这是一个基于Rust的工具，旨在为LLMs提供恰到好处的上下文。

在本文中，我将分享我的经验，并解释为什么我相信`code2prompt`在今天是相关的，并且可以很好地集成，为什么它成为了我更好、更快地进行AI编码工作流程的首选解决方案。

## 我与LLMs的初步接触 👣

我于2023年11月开始在`OpenAI Playground`上使用`text-davinci-003`尝试LLMs。语言模型开启了一场新的革命。感觉就像拥有一个出色的新助手，可以几乎按照命令生成单元测试和文档字符串。我喜欢将模型推向极限——测试从闲聊和伦理困境到越狱和复杂编码任务的一切。然而，当我承担更大的项目时，我很快意识到模型有明显的局限性。起初，我只能将几百行代码放入上下文窗口，即使如此，模型也经常难以理解代码的目的或结构。这就是为什么我迅速意识到上下文的重要性至关重要。我的指令越简洁，上下文越好，结果就越好。

![OpenAI Playground](/assets/blog/post1/playground.png)

## 模型演进 🏗️

模型可以产生令人印象深刻的结果，但往往难以处理较大的代码库或复杂的任务。我发现自己花费更多时间编写提示词，而不是实际编码。同时，模型通过发布新版本不断改进。它们增加了推理能力和上下文大小，提供了新的视角和可能性。我可以将近2000行代码放入上下文窗口，然后结果就改进了。我可以在几个迭代中编写整个功能，并且我对快速获得结果的速度感到惊讶。我相信LLMs是编码的未来，并且我想成为这场革命的一部分。我坚信，AI不会取代我们，但会以人类仍然是专家和控制者的助手形式辅助我们。

## 我与LLMs的第一个项目 🚀

我开始编写一个`ROS`路径查找模块，用于机器人竞赛，为一个干净架构的`Flutter`跨平台应用程序生成功能，并制作了一个小型的`Next.js`网页应用程序来跟踪我的费用。我在一个晚上使用一个我从未接触过的框架构建了这个小型应用程序，这是一个改变游戏规则的时刻；LLMs不仅仅是工具，而是倍增器。我开发了`bboxconverter`，一个用于转换边界框的包，还有很多其他项目。LLMs可以帮助您快速学习新技术和框架；这很棒。

## 一个新的范式：软件3.0 💡

我深入研究了LLMs，并开始围绕它们构建智能体和脚手架。我重现了著名的论文[RestGPT](https://restgpt.github.io/)。这个想法非常棒：给LLMs调用某些REST API的能力，使用OpenAPI规范，如`Spotify`或`TMDB`。这些功能引入了一种新的软件编程范式，我称之为**软件3.0**。

| 软件1.0  | 软件2.0  | 软件3.0  |
| -------- | -------- | -------- |
| 基于规则 | 数据驱动 | 智能代理 |

同样的想法推动了[MCP](https://modelcontextprotocol.io/introduction)协议的发展，该协议允许LLMs直接调用工具和资源，而无需设计工具描述即可被LLM调用，不像REST Apis那样不一定需要OpenAPI规范。

## LLMs的局限性 🧩

### 幻觉 🌀

在重现著名的论文`RESTGPT`时，我注意到了LLMs的一些严重局限性。论文作者遇到了与我相同的问题：LLMs正在**幻觉**。它们生成未实现的代码，发明参数，简单地逐字遵循指令，而不利用常识。例如，在原始RestGPT代码库中，作者在[调用者提示](https://github.com/Yifan-Song793/RestGPT/blob/main/model/caller.py)中要求。

> “不要耍聪明，不要编造计划中不存在的步骤。”

我觉得这句话很有趣，也非常有趣，因为这是我第一次遇到有人指示LLMs不要幻觉。

### 上下文大小受限 📏

另一个限制是上下文大小；LLMs在寻找关键信息时表现良好，但难以理解它。当你给语言模型太多上下文时，它们往往会陷入细节，失去对全局的把握，这很令人沮丧，需要不断调整。我认为这与[维数诅咒](https://towardsdatascience.com/curse-of-dimensionality-a-curse-to-machine-learning-c122ee33bfeb)类似。把“维数”或“特征”替换为“上下文”，你就明白了。

![Curse of Dimensionality](/assets/blog/post1/curse_of_dimensionality.png)

你给LLM的上下文越多，就越难找到正确答案。我总结了这个想法的妙语：

> 提供尽可能少但必要的上下文

这高度受到瑞士政治家[Alain Berset](https://www.lematin.ch/story/alain-berset-la-formule-qui-defie-le-temps-166189802108)的名言启发，他在COVID-19封锁期间说过：

> “我们希望尽快行动，但也需要时放慢速度”

这代表了折衷的想法，也适用于LLMs的上下文大小！

## 寻找更好的方法：code2prompt 🔨

因此，我需要一种方法来快速加载、过滤和组织代码上下文，通过提供尽可能少但高质量的上下文。我尝试手动复制文件或代码片段到提示中，但这变得笨拙且容易出错。我知道自动化构造上下文以提出更好提示的繁琐过程会有帮助。然后，有一天，我在谷歌上输入了“code2prompt”，希望能找到一个可以直接将代码输送到提示的工具。

果然，我发现了一个由[Mufeed](https://www.reddit.com/r/rust/comments/1bghroh/i_made_code2prompt_a_cli_tool_to_convert_your/)创建的**基于Rust的项目**，名为*code2prompt*，在GitHub上拥有大约200个星标。当时，它仍然很基础：一个简单的CLI工具，具有基本的过滤能力和模板。我看到了巨大的潜力，于是直接跳进去贡献，实现了glob模式匹配等功能，并很快成为主要贡献者。

## 愿景与集成 🔮

如今，有几种方法可以为LLMs提供上下文。从更大的上下文中生成，使用检索增强生成（RAG），[压缩代码](https://www.all-hands.dev/blog/openhands-context-condensensation-for-more-efficient-ai-agents)，甚至使用这些方法的组合。上下文构造是一个热门话题，在未来几个月内将迅速发展。然而，我的方法是**KISS**：保持简单，笨蛋。向LLMs提供上下文的最简单有效的方法是使用最简单的方法。你精确构造所需的上下文；它是确定性的，这与RAG相反。

这就是为什么我决定将`code2prompt`作为一个简单的工具进一步推动，可以在任何工作流中使用。我希望它易于使用、集成和扩展。这就是为什么我添加了与工具交互的新方法。

- **核心**: `code2prompt`的核心是一个Rust库，提供从代码库中构造上下文的基本功能。它包括一个简单的API来加载、过滤和组织代码上下文。
- **CLI**: 命令行界面是使用`code2prompt`的最简单方式。你可以构造代码库的上下文，并直接将其输送到提示中。
- **Python API**: Python API是围绕CLI的简单包装器，允许你在Python脚本和智能体中使用`code2prompt`。你可以构造代码库的上下文，并直接将其输送到提示中。
- **MCP**: `code2prompt` MCP服务器允许LLMs使用`code2prompt`作为工具，从而使自己能够构造上下文。

更多信息请参见文档中的[愿景页面](/docs/vision)。

## 与智能体集成 👤

我相信未来的智能体需要一种方法来摄取上下文，而`code2prompt`是一种简单有效的方法，适用于基于文本的存储库，如代码库、文档或笔记。一个典型的地方是在具有有意义的命名约定的代码库中使用`code2prompt`。例如，在干净的架构中，关注点和层之间有清晰的分离。相关的上下文通常驻留在不同的文件和文件夹中，但共享相同的名称。这是`code2prompt`的完美用例，您可以使用glob模式来获取相关文件。

**基于Glob模式**：以最小的麻烦精确选择或排除文件。

此外，核心库被设计为有状态的上下文管理器，允许您在与LLM的对话过程中添加或删除文件。当为特定任务或目标提供上下文时，这特别有用。您可以轻松地添加或删除文件，而无需重新运行进程。

**有状态上下文**：在与LLM的对话过程中添加或删除文件。

这些功能使`code2prompt`成为基于智能体的工作流的理想选择。MCP服务器允许与流行的AI智能体框架（如[Aider](https://github.com/paul-gauthier/aider）、[Goose](https://block.github.io/goose/)或[Cline](https://github.com/jhillyerd/cline)）无缝集成。让它们处理复杂目标的同时，`code2prompt`提供完美的代码上下文。

## 为什么Code2prompt很重要 ✊

随着LLMs的发展和上下文窗口的扩大，简单地将整个存储库强制输入提示可能看起来足够了。然而，**Token成本**和**提示连贯性**仍然是小公司和开发者的重大障碍。专注于最重要的代码，`code2prompt`使您的LLM使用效率高、成本效益高，并且不容易产生幻觉。

**简而言之：**

- **减少幻觉**：通过提供适量的上下文
- **降低Token使用**成本：通过手动管理所需的适当上下文
- **提高LLM性能**：通过提供适量的上下文
- 将智能体堆栈集成作为文本存储库的上下文提供者

## 加入开源！ 🌐

欢迎每一位新贡献者！如果您对Rust、构造创新AI工具感兴趣，或者只是想要一个更好的基于代码提示的工作流，请加入我们。

感谢阅读，我希望我的故事能激励您尝试code2prompt。这是一段令人难以置信的旅程，才刚刚开始！

**Olivier D'Ancona**

> 为了您的方便，本页面已自动翻译。请参考英文版本获取原始内容。
